
<link rel="stylesheet" href="{{ '/assets/css/lightbox.css' | relative_url }}">
<div class="lb-overlay" id="lb" aria-modal="true" role="dialog" aria-label="Media viewer">
  <button class="lb-nav lb-prev" id="lb-prev" aria-label="Previous">‹</button>
  <div class="lb-content" id="lb-content">
    <button class="lb-close" id="lb-close" aria-label="Close">×</button>
  </div>
  <button class="lb-nav lb-next" id="lb-next" aria-label="Next">›</button>
  <div class="lb-caption" id="lb-caption" aria-live="polite"></div>
</div>

<script>
(function() {
  const overlay = document.getElementById('lb');
  const content = document.getElementById('lb-content');
  const closeBtn = document.getElementById('lb-close');
  const prevBtn = document.getElementById('lb-prev');
  const nextBtn = document.getElementById('lb-next');
  const captionEl = document.getElementById('lb-caption');
  const body = document.body;

  let currentGroup = null;
  let items = [];
  let index = 0;
  let currentDirection = 'forward';
  let storedScroll = 0;
  const MAX_SCALE = 4;
  let activeMedia = null;
  let activeType = null;
  let scale = 1;
  let baseScale = 1;
  let startDistance = 0;
  let panX = 0;
  let panY = 0;
  let panStart = { x: 0, y: 0 };
  let panStartTouch = { x: 0, y: 0 };
  let isZooming = false;
  let isPanning = false;

  function disableScroll() {
    storedScroll = window.scrollY || document.documentElement.scrollTop || 0;
    body.style.top = `-${storedScroll}px`;
    body.style.position = 'fixed';
    body.style.width = '100%';
    body.classList.add('lb-no-scroll');
  }

  function enableScroll() {
    body.classList.remove('lb-no-scroll');
    body.style.top = '';
    body.style.position = '';
    body.style.width = '';
    window.scrollTo(0, storedScroll);
  }

  const clamp = (value, min, max) => Math.min(max, Math.max(min, value));

  function resetZoomState() {
    scale = 1;
    baseScale = 1;
    startDistance = 0;
    panX = 0;
    panY = 0;
    panStart = { x: 0, y: 0 };
    panStartTouch = { x: 0, y: 0 };
    isZooming = false;
    isPanning = false;
  }

  function clearActiveMedia() {
    if (activeMedia) {
      activeMedia.style.transform = '';
      activeMedia.style.transition = '';
      activeMedia.style.cursor = '';
    }
    activeMedia = null;
    activeType = null;
  }

  function prepareActiveMedia(el, type) {
    clearActiveMedia();
    resetZoomState();
    activeMedia = el;
    activeType = type;
    if (activeMedia && activeType === 'image') {
      activeMedia.style.transformOrigin = 'center center';
      activeMedia.style.transform = 'translate3d(0,0,0) scale(1)';
    }
  }

  function clampPan() {
    if (!activeMedia || activeType !== 'image') return;
    const maxX = (activeMedia.offsetWidth * (scale - 1)) / 2;
    const maxY = (activeMedia.offsetHeight * (scale - 1)) / 2;
    panX = maxX > 0 ? clamp(panX, -maxX, maxX) : 0;
    panY = maxY > 0 ? clamp(panY, -maxY, maxY) : 0;
  }

  function applyTransform() {
    if (!activeMedia || activeType !== 'image') return;
    clampPan();
    activeMedia.style.transition = 'transform 0s';
    activeMedia.style.cursor = scale > 1 ? 'grab' : '';
    activeMedia.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }

  function clearContent() {
    clearActiveMedia();
    resetZoomState();
    // remove everything except the close button
    Array.from(content.children).forEach((child) => {
      if (child !== closeBtn) child.remove();
    });
  }

  function setCaption(text) {
    if (text && text.trim().length > 0) {
      captionEl.textContent = text;
      captionEl.style.display = 'block';
    } else {
      captionEl.textContent = '';
      captionEl.style.display = 'none';
    }
  }

  function renderItem(it) {
    clearContent();
    content.classList.remove('anim-forward', 'anim-backward');

    if (it.type === 'image') {
      const img = document.createElement('img');
      img.src = it.src;
      img.alt = it.caption || 'Image';
      content.insertBefore(img, closeBtn);
      prepareActiveMedia(img, 'image');
    } else if (it.type === 'video') {
      const vid = document.createElement('video');
      vid.controls = true;
      vid.autoplay = true;
      vid.playsInline = true;
      vid.setAttribute('playsinline', '');
      vid.setAttribute('webkit-playsinline', '');
      const type = 'video/' + (it.src.split('.').pop().split('?')[0].toLowerCase());
      const source = document.createElement('source');
      source.src = it.src;
      source.type = type;
      vid.appendChild(source);
      content.insertBefore(vid, closeBtn);
      prepareActiveMedia(vid, 'video');
    } else if (it.type === 'youtube') {
      const wrap = document.createElement('div');
      wrap.className = 'yt-wrap-inlb';
      const iframe = document.createElement('iframe');
      iframe.src = 'https://www.youtube.com/embed/' + it.ytid;
      iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
      iframe.allowFullscreen = true;
      iframe.frameBorder = '0';
      wrap.appendChild(iframe);
      content.insertBefore(wrap, closeBtn);
      prepareActiveMedia(null, 'youtube');
    } else if (it.type === 'map') {
      const wrap = document.createElement('div');
      wrap.className = 'map-wrap-inlb';
      const iframe = document.createElement('iframe');
      iframe.src = it.src;
      iframe.loading = 'lazy';
      iframe.referrerPolicy = 'no-referrer-when-downgrade';
      iframe.allowFullscreen = true;
      wrap.appendChild(iframe);
      content.insertBefore(wrap, closeBtn);
      prepareActiveMedia(null, 'map');
    }
    setCaption(it.caption || '');

    const animClass = currentDirection === 'backward' ? 'anim-backward' : 'anim-forward';
    requestAnimationFrame(() => {
      content.classList.remove('anim-forward', 'anim-backward');
      void content.offsetWidth;
      content.classList.add(animClass);
    });
  }

  function open(group, startIndex) {
    currentGroup = group;
    index = startIndex || 0;
    currentDirection = 'forward';
    overlay.classList.add('open');
    disableScroll();
    renderItem(items[index]);
  }

  function close() {
    overlay.classList.remove('open');
    clearActiveMedia();
    resetZoomState();
    // Stop any playing video by clearing soon
    setTimeout(clearContent, 150);
    enableScroll();
  }

  function collectGroup(group) {
    const nodes = document.querySelectorAll('[data-group="' + group + '"]');
    items = Array.from(nodes).map((el) => {
      const type = el.getAttribute('data-type');
      const caption = el.getAttribute('data-caption') || '';
      if (type === 'youtube') {
        return { type, ytid: el.getAttribute('data-ytid'), caption };
      } else {
        return { type, src: el.getAttribute('data-src'), caption };
      }
    });
  }

  function next() {
    if (!items.length) return;
    index = (index + 1) % items.length;
    currentDirection = 'forward';
    renderItem(items[index]);
  }
  function prev() {
    if (!items.length) return;
    index = (index - 1 + items.length) % items.length;
    currentDirection = 'backward';
    renderItem(items[index]);
  }

  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) close();
  });
  closeBtn.addEventListener('click', close);
  nextBtn.addEventListener('click', next);
  prevBtn.addEventListener('click', prev);

  
// Touch & gesture handlers (mobile)
let touchStartX = 0;
let touchStartY = 0;
let touchActive = false;

function onTouchStart(e) {
  if (!overlay.classList.contains('open')) return;
  const touches = e.touches || e.targetTouches;
  if (!touches || touches.length === 0) return;

  if (touches.length === 2 && activeType === 'image' && activeMedia) {
    isZooming = true;
    touchActive = false;
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    startDistance = Math.hypot(dx, dy);
    baseScale = scale;
    e.preventDefault();
    return;
  }

  if (scale > 1 && touches.length === 1 && activeType === 'image' && activeMedia) {
    isPanning = true;
    touchActive = false;
    panStartTouch = { x: touches[0].clientX, y: touches[0].clientY };
    panStart = { x: panX, y: panY };
    activeMedia.style.cursor = 'grabbing';
    e.preventDefault();
    return;
  }

  touchActive = true;
  touchStartX = touches[0].clientX;
  touchStartY = touches[0].clientY;
}

function onTouchMove(e) {
  if (!overlay.classList.contains('open')) return;
  const touches = e.touches || e.targetTouches;
  if (!touches || touches.length === 0) return;

  if (touches.length === 2 && activeType === 'image' && activeMedia) {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    const distance = Math.hypot(dx, dy);
    if (!startDistance) {
      startDistance = distance;
      baseScale = scale;
    }
    scale = clamp(baseScale * (distance / startDistance), 1, MAX_SCALE);
    if (scale === 1) {
      panX = 0;
      panY = 0;
    }
    applyTransform();
    touchActive = false;
    isZooming = true;
    e.preventDefault();
    return;
  }

  if (isPanning && touches.length === 1 && activeType === 'image' && activeMedia) {
    const t = touches[0];
    panX = panStart.x + (t.clientX - panStartTouch.x);
    panY = panStart.y + (t.clientY - panStartTouch.y);
    applyTransform();
    e.preventDefault();
    return;
  }

  if (scale > 1) {
    touchActive = false;
  }
}

function onTouchEnd(e) {
  const touches = e.touches || e.targetTouches;

  if (isZooming && (!touches || touches.length < 2)) {
    isZooming = false;
    startDistance = 0;
    baseScale = scale;
    if (scale <= 1.01) {
      scale = 1;
      panX = 0;
      panY = 0;
    }
    applyTransform();
  }

  if (isPanning && (!touches || touches.length === 0)) {
    isPanning = false;
    if (activeMedia && activeType === 'image') {
      activeMedia.style.cursor = scale > 1 ? 'grab' : '';
    }
  }

  if (!touches || touches.length === 0) {
    baseScale = scale;
    panStart = { x: panX, y: panY };
  }

  if (scale > 1) {
    touchActive = false;
  }

  if (!touchActive) return;

  const t = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : e;
  const dx = t.clientX - touchStartX;
  const dy = t.clientY - touchStartY;
  touchActive = false;
  if (Math.abs(dx) > 48 && Math.abs(dx) > Math.abs(dy)) {
    if (dx < 0) next(); else prev();
  }
}

overlay.addEventListener('touchstart', onTouchStart, {passive: false});
overlay.addEventListener('touchmove', onTouchMove, {passive: false});
overlay.addEventListener('touchend', onTouchEnd, {passive: false});
overlay.addEventListener('touchcancel', onTouchEnd, {passive: false});
overlay.addEventListener('wheel', (e) => {
  if (overlay.classList.contains('open')) {
    e.preventDefault();
  }
}, {passive: false});

document.addEventListener('keydown', (e) => {

    if (!overlay.classList.contains('open')) return;
    if (e.key === 'Escape') close();
    if (e.key === 'ArrowRight') next();
    if (e.key === 'ArrowLeft') prev();
  });

  // Delegate clicks from day-media elements
  document.addEventListener('click', (e) => {
    const a = e.target.closest('.day-media a.ph, .day-media button.ph, .day-media .map-wrap');
    if (!a) return;

    e.preventDefault();
    const group = a.getAttribute('data-group');

    // build items for this group
    collectGroup(group);

    // find start index
    const nodes = Array.from(document.querySelectorAll('[data-group="' + group + '"]'));
    const startIndex = nodes.indexOf(a);
    open(group, Math.max(0, startIndex));
  });
})();
</script>
